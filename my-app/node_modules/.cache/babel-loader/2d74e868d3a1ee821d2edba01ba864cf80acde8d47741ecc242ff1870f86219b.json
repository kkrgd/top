{"ast":null,"code":"/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.4.6\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n(function () {\n  'use strict';\n\n  /**\n   * Pathformer\n   * Beta version\n   *\n   * Take any SVG version 1.1 and transform\n   * child elements to 'path' elements\n   *\n   * This code is purely forked from\n   * https://github.com/Waest/SVGPathConverter\n   */\n\n  /**\n   * Class constructor\n   *\n   * @param {DOM|String} element Dom element of the SVG or id of it\n   */\n  function Pathformer(element) {\n    // Test params\n    if (typeof element === 'undefined') {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n    }\n\n    // Set the element\n    if (element.constructor === String) {\n      element = document.getElementById(element);\n      if (!element) {\n        throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n      }\n    }\n    if (element instanceof window.SVGElement || element instanceof window.SVGGElement || /^svg$/i.test(element.nodeName)) {\n      this.el = element;\n    } else {\n      throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n    }\n\n    // Start\n    this.scan(element);\n  }\n\n  /**\n   * List of tags which can be transformed\n   * to path elements\n   *\n   * @type {Array}\n   */\n  Pathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n  /**\n   * List of attribute names which contain\n   * data. This array list them to check if\n   * they contain bad values, like percentage.\n   *\n   * @type {Array}\n   */\n  Pathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n  /**\n   * Finds the elements compatible for transform\n   * and apply the liked method\n   *\n   * @param  {object} options Object from the constructor\n   */\n  Pathformer.prototype.scan = function (svg) {\n    var fn,\n      element,\n      pathData,\n      pathDom,\n      elements = svg.querySelectorAll(this.TYPES.join(','));\n    for (var i = 0; i < elements.length; i++) {\n      element = elements[i];\n      fn = this[element.tagName.toLowerCase() + 'ToPath'];\n      pathData = fn(this.parseAttr(element.attributes));\n      pathDom = this.pathMaker(element, pathData);\n      element.parentNode.replaceChild(pathDom, element);\n    }\n  };\n\n  /**\n   * Read `line` element to extract and transform\n   * data, to make it ready for a `path` object.\n   *\n   * @param  {DOMelement} element Line element to transform\n   * @return {object}             Data for a `path` element\n   */\n  Pathformer.prototype.lineToPath = function (element) {\n    var newElement = {},\n      x1 = element.x1 || 0,\n      y1 = element.y1 || 0,\n      x2 = element.x2 || 0,\n      y2 = element.y2 || 0;\n    newElement.d = 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n    return newElement;\n  };\n\n  /**\n   * Read `rect` element to extract and transform\n   * data, to make it ready for a `path` object.\n   * The radius-border is not taken in charge yet.\n   * (your help is more than welcomed)\n   *\n   * @param  {DOMelement} element Rect element to transform\n   * @return {object}             Data for a `path` element\n   */\n  Pathformer.prototype.rectToPath = function (element) {\n    var newElement = {},\n      x = parseFloat(element.x) || 0,\n      y = parseFloat(element.y) || 0,\n      width = parseFloat(element.width) || 0,\n      height = parseFloat(element.height) || 0;\n    if (element.rx || element.ry) {\n      var rx = parseInt(element.rx, 10) || -1,\n        ry = parseInt(element.ry, 10) || -1;\n      rx = Math.min(Math.max(rx < 0 ? ry : rx, 0), width / 2);\n      ry = Math.min(Math.max(ry < 0 ? rx : ry, 0), height / 2);\n      newElement.d = 'M ' + (x + rx) + ',' + y + ' ' + 'L ' + (x + width - rx) + ',' + y + ' ' + 'A ' + rx + ',' + ry + ',0,0,1,' + (x + width) + ',' + (y + ry) + ' ' + 'L ' + (x + width) + ',' + (y + height - ry) + ' ' + 'A ' + rx + ',' + ry + ',0,0,1,' + (x + width - rx) + ',' + (y + height) + ' ' + 'L ' + (x + rx) + ',' + (y + height) + ' ' + 'A ' + rx + ',' + ry + ',0,0,1,' + x + ',' + (y + height - ry) + ' ' + 'L ' + x + ',' + (y + ry) + ' ' + 'A ' + rx + ',' + ry + ',0,0,1,' + (x + rx) + ',' + y;\n    } else {\n      newElement.d = 'M' + x + ' ' + y + ' ' + 'L' + (x + width) + ' ' + y + ' ' + 'L' + (x + width) + ' ' + (y + height) + ' ' + 'L' + x + ' ' + (y + height) + ' Z';\n    }\n    return newElement;\n  };\n\n  /**\n   * Read `polyline` element to extract and transform\n   * data, to make it ready for a `path` object.\n   *\n   * @param  {DOMelement} element Polyline element to transform\n   * @return {object}             Data for a `path` element\n   */\n  Pathformer.prototype.polylineToPath = function (element) {\n    var newElement = {},\n      points = element.points.trim().split(' '),\n      i,\n      path;\n\n    // Reformatting if points are defined without commas\n    if (element.points.indexOf(',') === -1) {\n      var formattedPoints = [];\n      for (i = 0; i < points.length; i += 2) {\n        formattedPoints.push(points[i] + ',' + points[i + 1]);\n      }\n      points = formattedPoints;\n    }\n\n    // Generate the path.d value\n    path = 'M' + points[0];\n    for (i = 1; i < points.length; i++) {\n      if (points[i].indexOf(',') !== -1) {\n        path += 'L' + points[i];\n      }\n    }\n    newElement.d = path;\n    return newElement;\n  };\n\n  /**\n   * Read `polygon` element to extract and transform\n   * data, to make it ready for a `path` object.\n   * This method rely on polylineToPath, because the\n   * logic is similar. The path created is just closed,\n   * so it needs an 'Z' at the end.\n   *\n   * @param  {DOMelement} element Polygon element to transform\n   * @return {object}             Data for a `path` element\n   */\n  Pathformer.prototype.polygonToPath = function (element) {\n    var newElement = Pathformer.prototype.polylineToPath(element);\n    newElement.d += 'Z';\n    return newElement;\n  };\n\n  /**\n   * Read `ellipse` element to extract and transform\n   * data, to make it ready for a `path` object.\n   *\n   * @param  {DOMelement} element ellipse element to transform\n   * @return {object}             Data for a `path` element\n   */\n  Pathformer.prototype.ellipseToPath = function (element) {\n    var newElement = {},\n      rx = parseFloat(element.rx) || 0,\n      ry = parseFloat(element.ry) || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - rx,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(rx),\n      endY = cy;\n    newElement.d = 'M' + startX + ',' + startY + 'A' + rx + ',' + ry + ' 0,1,1 ' + endX + ',' + endY + 'A' + rx + ',' + ry + ' 0,1,1 ' + startX + ',' + endY;\n    return newElement;\n  };\n\n  /**\n   * Read `circle` element to extract and transform\n   * data, to make it ready for a `path` object.\n   *\n   * @param  {DOMelement} element Circle element to transform\n   * @return {object}             Data for a `path` element\n   */\n  Pathformer.prototype.circleToPath = function (element) {\n    var newElement = {},\n      r = parseFloat(element.r) || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - r,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(r),\n      endY = cy;\n    newElement.d = 'M' + startX + ',' + startY + 'A' + r + ',' + r + ' 0,1,1 ' + endX + ',' + endY + 'A' + r + ',' + r + ' 0,1,1 ' + startX + ',' + endY;\n    return newElement;\n  };\n\n  /**\n   * Create `path` elements form original element\n   * and prepared objects\n   *\n   * @param  {DOMelement} element  Original element to transform\n   * @param  {object} pathData     Path data (from `toPath` methods)\n   * @return {DOMelement}          Path element\n   */\n  Pathformer.prototype.pathMaker = function (element, pathData) {\n    var i,\n      attr,\n      pathTag = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    for (i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n        pathTag.setAttribute(attr.name, attr.value);\n      }\n    }\n    for (i in pathData) {\n      pathTag.setAttribute(i, pathData[i]);\n    }\n    return pathTag;\n  };\n\n  /**\n   * Parse attributes of a DOM element to\n   * get an object of attribute => value\n   *\n   * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n   * @return {object}                  Object of attributes\n   */\n  Pathformer.prototype.parseAttr = function (element) {\n    var attr,\n      output = {};\n    for (var i = 0; i < element.length; i++) {\n      attr = element[i];\n      // Check if no data attribute contains '%', or the transformation is impossible\n      if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n        throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n      }\n      output[attr.name] = attr.value;\n    }\n    return output;\n  };\n  'use strict';\n  var setupEnv, requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n  /**\n   * Vivus\n   * Beta version\n   *\n   * Take any SVG and make the animation\n   * to give give the impression of live drawing\n   *\n   * This in more than just inspired from codrops\n   * At that point, it's a pure fork.\n   */\n\n  /**\n   * Class constructor\n   * option structure\n   *   type: 'delayed'|'sync'|'oneByOne'|'script' (to know if the items must be drawn synchronously or not, default: delayed)\n   *   duration: <int> (in frames)\n   *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n   *   delay: <int> (delay between the drawing of first and last path)\n   *   dashGap <integer> whitespace extra margin between dashes\n   *   pathTimingFunction <function> timing animation function for each path element of the SVG\n   *   animTimingFunction <function> timing animation function for the complete SVG\n   *   forceRender <boolean> force the browser to re-render all updated path items\n   *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n   *\n   * The attribute 'type' is by default on 'delayed'.\n   *  - 'delayed'\n   *    all paths are draw at the same time but with a\n   *    little delay between them before start\n   *  - 'sync'\n   *    all path are start and finish at the same time\n   *  - 'oneByOne'\n   *    only one path is draw at the time\n   *    the end of the first one will trigger the draw\n   *    of the next one\n   *\n   * All these values can be overwritten individually\n   * for each path item in the SVG\n   * The value of frames will always take the advantage of\n   * the duration value.\n   * If you fail somewhere, an error will be thrown.\n   * Good luck.\n   *\n   * @constructor\n   * @this {Vivus}\n   * @param {DOM|String}   element  Dom element of the SVG or id of it\n   * @param {Object}       options  Options about the animation\n   * @param {Function}     callback Callback for the end of the animation\n   */\n  function Vivus(element, options, callback) {\n    setupEnv();\n\n    // Setup\n    this.isReady = false;\n    this.setElement(element, options);\n    this.setOptions(options);\n    this.setCallback(callback);\n    if (this.isReady) {\n      this.init();\n    }\n  }\n\n  /**\n   * Timing functions\n   **************************************\n   *\n   * Default functions to help developers.\n   * It always take a number as parameter (between 0 to 1) then\n   * return a number (between 0 and 1)\n   */\n  Vivus.LINEAR = function (x) {\n    return x;\n  };\n  Vivus.EASE = function (x) {\n    return -Math.cos(x * Math.PI) / 2 + 0.5;\n  };\n  Vivus.EASE_OUT = function (x) {\n    return 1 - Math.pow(1 - x, 3);\n  };\n  Vivus.EASE_IN = function (x) {\n    return Math.pow(x, 3);\n  };\n  Vivus.EASE_OUT_BOUNCE = function (x) {\n    var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n      rate = Math.pow(base, 1.5),\n      rateR = Math.pow(1 - x, 2),\n      progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI))) + 1;\n    return 1 - rateR + progress * rateR;\n  };\n\n  /**\n   * Setters\n   **************************************\n   */\n\n  /**\n   * Check and set the element in the instance\n   * The method will not return anything, but will throw an\n   * error if the parameter is invalid\n   *\n   * @param {DOM|String}   element  SVG Dom element or id of it\n   */\n  Vivus.prototype.setElement = function (element, options) {\n    var onLoad, self;\n\n    // Basic check\n    if (typeof element === 'undefined') {\n      throw new Error('Vivus [constructor]: \"element\" parameter is required');\n    }\n\n    // Set the element\n    if (element.constructor === String) {\n      element = document.getElementById(element);\n      if (!element) {\n        throw new Error('Vivus [constructor]: \"element\" parameter is not related to an existing ID');\n      }\n    }\n    this.parentEl = element;\n\n    // Load the SVG with XMLHttpRequest and extract the SVG\n    if (options && options.file) {\n      self = this;\n      onLoad = function () {\n        var domSandbox = document.createElement('div');\n        domSandbox.innerHTML = this.responseText;\n        var svgTag = domSandbox.querySelector('svg');\n        if (!svgTag) {\n          throw new Error('Vivus [load]: Cannot find the SVG in the loaded file : ' + options.file);\n        }\n        self.el = svgTag;\n        self.el.setAttribute('width', '100%');\n        self.el.setAttribute('height', '100%');\n        self.parentEl.appendChild(self.el);\n        self.isReady = true;\n        self.init();\n        self = null;\n      };\n      var oReq = new window.XMLHttpRequest();\n      oReq.addEventListener('load', onLoad);\n      oReq.open('GET', options.file);\n      oReq.send();\n      return;\n    }\n    switch (element.constructor) {\n      case window.SVGSVGElement:\n      case window.SVGElement:\n      case window.SVGGElement:\n        this.el = element;\n        this.isReady = true;\n        break;\n      case window.HTMLObjectElement:\n        self = this;\n        onLoad = function (e) {\n          if (self.isReady) {\n            return;\n          }\n          self.el = element.contentDocument && element.contentDocument.querySelector('svg');\n          if (!self.el && e) {\n            throw new Error('Vivus [constructor]: object loaded does not contain any SVG');\n          } else if (self.el) {\n            if (element.getAttribute('built-by-vivus')) {\n              self.parentEl.insertBefore(self.el, element);\n              self.parentEl.removeChild(element);\n              self.el.setAttribute('width', '100%');\n              self.el.setAttribute('height', '100%');\n            }\n            self.isReady = true;\n            self.init();\n            self = null;\n          }\n        };\n        if (!onLoad()) {\n          element.addEventListener('load', onLoad);\n        }\n        break;\n      default:\n        throw new Error('Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)');\n    }\n  };\n\n  /**\n   * Set up user option to the instance\n   * The method will not return anything, but will throw an\n   * error if the parameter is invalid\n   *\n   * @param  {object} options Object from the constructor\n   */\n  Vivus.prototype.setOptions = function (options) {\n    var allowedTypes = ['delayed', 'sync', 'async', 'nsync', 'oneByOne', 'scenario', 'scenario-sync'];\n    var allowedStarts = ['inViewport', 'manual', 'autostart'];\n\n    // Basic check\n    if (options !== undefined && options.constructor !== Object) {\n      throw new Error('Vivus [constructor]: \"options\" parameter must be an object');\n    } else {\n      options = options || {};\n    }\n\n    // Set the animation type\n    if (options.type && allowedTypes.indexOf(options.type) === -1) {\n      throw new Error('Vivus [constructor]: ' + options.type + ' is not an existing animation `type`');\n    } else {\n      this.type = options.type || allowedTypes[0];\n    }\n\n    // Set the start type\n    if (options.start && allowedStarts.indexOf(options.start) === -1) {\n      throw new Error('Vivus [constructor]: ' + options.start + ' is not an existing `start` option');\n    } else {\n      this.start = options.start || allowedStarts[0];\n    }\n    this.isIE = window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.userAgent.indexOf('Trident/') !== -1 || window.navigator.userAgent.indexOf('Edge/') !== -1;\n    this.duration = parsePositiveInt(options.duration, 120);\n    this.delay = parsePositiveInt(options.delay, null);\n    this.dashGap = parsePositiveInt(options.dashGap, 1);\n    this.forceRender = options.hasOwnProperty('forceRender') ? !!options.forceRender : this.isIE;\n    this.reverseStack = !!options.reverseStack;\n    this.selfDestroy = !!options.selfDestroy;\n    this.onReady = options.onReady;\n    this.map = [];\n    this.frameLength = this.currentFrame = this.delayUnit = this.speed = this.handle = null;\n    this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible') ? !!options.ignoreInvisible : false;\n    this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n    this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n    if (this.delay >= this.duration) {\n      throw new Error('Vivus [constructor]: delay must be shorter than duration');\n    }\n  };\n\n  /**\n   * Set up callback to the instance\n   * The method will not return enything, but will throw an\n   * error if the parameter is invalid\n   *\n   * @param  {Function} callback Callback for the animation end\n   */\n  Vivus.prototype.setCallback = function (callback) {\n    // Basic check\n    if (!!callback && callback.constructor !== Function) {\n      throw new Error('Vivus [constructor]: \"callback\" parameter must be a function');\n    }\n    this.callback = callback || function () {};\n  };\n\n  /**\n   * Core\n   **************************************\n   */\n\n  /**\n   * Map the svg, path by path.\n   * The method return nothing, it just fill the\n   * `map` array. Each item in this array represent\n   * a path element from the SVG, with informations for\n   * the animation.\n   *\n   * ```\n   * [\n   *   {\n   *     el: <DOMobj> the path element\n   *     length: <number> length of the path line\n   *     startAt: <number> time start of the path animation (in frames)\n   *     duration: <number> path animation duration (in frames)\n   *   },\n   *   ...\n   * ]\n   * ```\n   *\n   */\n  Vivus.prototype.mapping = function () {\n    var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint, scale, hasNonScale;\n    timePoint = totalLength = lengthMeter = 0;\n    paths = this.el.querySelectorAll('path');\n    hasNonScale = false;\n    for (i = 0; i < paths.length; i++) {\n      path = paths[i];\n      if (this.isInvisible(path)) {\n        continue;\n      }\n      pathObj = {\n        el: path,\n        length: 0,\n        startAt: 0,\n        duration: 0,\n        isResizeSensitive: false\n      };\n\n      // If vector effect is non-scaling-stroke, the total length won't match the rendered length\n      // so we need to calculate the scale and apply it\n      if (path.getAttribute('vector-effect') === 'non-scaling-stroke') {\n        var rect = path.getBoundingClientRect();\n        var box = path.getBBox();\n        scale = Math.max(rect.width / box.width, rect.height / box.height);\n        pathObj.isResizeSensitive = true;\n        hasNonScale = true;\n      } else {\n        scale = 1;\n      }\n      pathObj.length = Math.ceil(path.getTotalLength() * scale);\n\n      // Test if the path length is correct\n      if (isNaN(pathObj.length)) {\n        if (window.console && console.warn) {\n          console.warn('Vivus [mapping]: cannot retrieve a path element length', path);\n        }\n        continue;\n      }\n      this.map.push(pathObj);\n      path.style.strokeDasharray = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n      path.style.strokeDashoffset = pathObj.length + this.dashGap;\n      pathObj.length += this.dashGap;\n      totalLength += pathObj.length;\n      this.renderPath(i);\n    }\n\n    // Show a warning for non-scaling elements\n    if (hasNonScale) {\n      console.warn('Vivus: this SVG contains non-scaling-strokes. You should call instance.recalc() when the SVG is resized or you will encounter unwanted behaviour. See https://github.com/maxwellito/vivus#non-scaling for more info.');\n    }\n    totalLength = totalLength === 0 ? 1 : totalLength;\n    this.delay = this.delay === null ? this.duration / 3 : this.delay;\n    this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n    // Reverse stack if asked\n    if (this.reverseStack) {\n      this.map.reverse();\n    }\n    for (i = 0; i < this.map.length; i++) {\n      pathObj = this.map[i];\n      switch (this.type) {\n        case 'delayed':\n          pathObj.startAt = this.delayUnit * i;\n          pathObj.duration = this.duration - this.delay;\n          break;\n        case 'oneByOne':\n          pathObj.startAt = lengthMeter / totalLength * this.duration;\n          pathObj.duration = pathObj.length / totalLength * this.duration;\n          break;\n        case 'sync':\n        case 'async':\n        case 'nsync':\n          pathObj.startAt = 0;\n          pathObj.duration = this.duration;\n          break;\n        case 'scenario-sync':\n          path = pathObj.el;\n          pAttrs = this.parseAttr(path);\n          pathObj.startAt = timePoint + (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n          pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n          timePoint = pAttrs['data-async'] !== undefined ? pathObj.startAt : pathObj.startAt + pathObj.duration;\n          this.frameLength = Math.max(this.frameLength, pathObj.startAt + pathObj.duration);\n          break;\n        case 'scenario':\n          path = pathObj.el;\n          pAttrs = this.parseAttr(path);\n          pathObj.startAt = parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n          pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n          this.frameLength = Math.max(this.frameLength, pathObj.startAt + pathObj.duration);\n          break;\n      }\n      lengthMeter += pathObj.length;\n      this.frameLength = this.frameLength || this.duration;\n    }\n  };\n\n  /**\n   * Public method to re-evaluate line length for non-scaling lines\n   * path elements.\n   */\n  Vivus.prototype.recalc = function () {\n    if (this.mustRecalcScale) {\n      return;\n    }\n    this.mustRecalcScale = requestAnimFrame(function () {\n      this.performLineRecalc();\n    }.bind(this));\n  };\n\n  /**\n   * Private method to re-evaluate line length on non-scaling\n   * path elements. Then call for a trace to update the SVG. \n   */\n  Vivus.prototype.performLineRecalc = function () {\n    var pathObj, path, rect, box, scale;\n    for (var i = 0; i < this.map.length; i++) {\n      pathObj = this.map[i];\n      if (pathObj.isResizeSensitive) {\n        path = pathObj.el;\n        rect = path.getBoundingClientRect();\n        box = path.getBBox();\n        scale = Math.max(rect.width / box.width, rect.height / box.height);\n        pathObj.length = Math.ceil(path.getTotalLength() * scale);\n        path.style.strokeDasharray = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n      }\n    }\n    this.trace();\n    this.mustRecalcScale = null;\n  };\n\n  /**\n   * Interval method to draw the SVG from current\n   * position of the animation. It update the value of\n   * `currentFrame` and re-trace the SVG.\n   *\n   * It use this.handle to store the requestAnimationFrame\n   * and clear it one the animation is stopped. So this\n   * attribute can be used to know if the animation is\n   * playing.\n   *\n   * Once the animation at the end, this method will\n   * trigger the Vivus callback.\n   *\n   */\n  Vivus.prototype.draw = function () {\n    var self = this;\n    this.currentFrame += this.speed;\n    if (this.currentFrame <= 0) {\n      this.stop();\n      this.reset();\n    } else if (this.currentFrame >= this.frameLength) {\n      this.stop();\n      this.currentFrame = this.frameLength;\n      this.trace();\n      if (this.selfDestroy) {\n        this.destroy();\n      }\n    } else {\n      this.trace();\n      this.handle = requestAnimFrame(function () {\n        self.draw();\n      });\n      return;\n    }\n    this.callback(this);\n    if (this.instanceCallback) {\n      this.instanceCallback(this);\n      this.instanceCallback = null;\n    }\n  };\n\n  /**\n   * Draw the SVG at the current instant from the\n   * `currentFrame` value. Here is where most of the magic is.\n   * The trick is to use the `strokeDashoffset` style property.\n   *\n   * For optimisation reasons, a new property called `progress`\n   * is added in each item of `map`. This one contain the current\n   * progress of the path element. Only if the new value is different\n   * the new value will be applied to the DOM element. This\n   * method save a lot of resources to re-render the SVG. And could\n   * be improved if the animation couldn't be played forward.\n   *\n   */\n  Vivus.prototype.trace = function () {\n    var i, progress, path, currentFrame;\n    currentFrame = this.animTimingFunction(this.currentFrame / this.frameLength) * this.frameLength;\n    for (i = 0; i < this.map.length; i++) {\n      path = this.map[i];\n      progress = (currentFrame - path.startAt) / path.duration;\n      progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n      if (path.progress !== progress) {\n        path.progress = progress;\n        path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n        this.renderPath(i);\n      }\n    }\n  };\n\n  /**\n   * Method forcing the browser to re-render a path element\n   * from it's index in the map. Depending on the `forceRender`\n   * value.\n   * The trick is to replace the path element by it's clone.\n   * This practice is not recommended because it's asking more\n   * ressources, too much DOM manupulation..\n   * but it's the only way to let the magic happen on IE.\n   * By default, this fallback is only applied on IE.\n   *\n   * @param  {Number} index Path index\n   */\n  Vivus.prototype.renderPath = function (index) {\n    if (this.forceRender && this.map && this.map[index]) {\n      var pathObj = this.map[index],\n        newPath = pathObj.el.cloneNode(true);\n      pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n      pathObj.el = newPath;\n    }\n  };\n\n  /**\n   * When the SVG object is loaded and ready,\n   * this method will continue the initialisation.\n   *\n   * This this mainly due to the case of passing an\n   * object tag in the constructor. It will wait\n   * the end of the loading to initialise.\n   *\n   */\n  Vivus.prototype.init = function () {\n    // Set object variables\n    this.frameLength = 0;\n    this.currentFrame = 0;\n    this.map = [];\n\n    // Start\n    new Pathformer(this.el);\n    this.mapping();\n    this.starter();\n    if (this.onReady) {\n      this.onReady(this);\n    }\n  };\n\n  /**\n   * Trigger to start of the animation.\n   * Depending on the `start` value, a different script\n   * will be applied.\n   *\n   * If the `start` value is not valid, an error will be thrown.\n   * Even if technically, this is impossible.\n   *\n   */\n  Vivus.prototype.starter = function () {\n    switch (this.start) {\n      case 'manual':\n        return;\n      case 'autostart':\n        this.play();\n        break;\n      case 'inViewport':\n        var self = this,\n          listener = function () {\n            if (self.isInViewport(self.parentEl, 1)) {\n              self.play();\n              window.removeEventListener('scroll', listener);\n            }\n          };\n        window.addEventListener('scroll', listener);\n        listener();\n        break;\n    }\n  };\n\n  /**\n   * Controls\n   **************************************\n   */\n\n  /**\n   * Get the current status of the animation between\n   * three different states: 'start', 'progress', 'end'.\n   * @return {string} Instance status\n   */\n  Vivus.prototype.getStatus = function () {\n    return this.currentFrame === 0 ? 'start' : this.currentFrame === this.frameLength ? 'end' : 'progress';\n  };\n\n  /**\n   * Reset the instance to the initial state : undraw\n   * Be careful, it just reset the animation, if you're\n   * playing the animation, this won't stop it. But just\n   * make it start from start.\n   *\n   */\n  Vivus.prototype.reset = function () {\n    return this.setFrameProgress(0);\n  };\n\n  /**\n   * Set the instance to the final state : drawn\n   * Be careful, it just set the animation, if you're\n   * playing the animation on rewind, this won't stop it.\n   * But just make it start from the end.\n   *\n   */\n  Vivus.prototype.finish = function () {\n    return this.setFrameProgress(1);\n  };\n\n  /**\n   * Set the level of progress of the drawing.\n   *\n   * @param {number} progress Level of progress to set\n   */\n  Vivus.prototype.setFrameProgress = function (progress) {\n    progress = Math.min(1, Math.max(0, progress));\n    this.currentFrame = Math.round(this.frameLength * progress);\n    this.trace();\n    return this;\n  };\n\n  /**\n   * Play the animation at the desired speed.\n   * Speed must be a valid number (no zero).\n   * By default, the speed value is 1.\n   * But a negative value is accepted to go forward.\n   *\n   * And works with float too.\n   * But don't forget we are in JavaScript, se be nice\n   * with him and give him a 1/2^x value.\n   *\n   * @param  {number} speed Animation speed [optional]\n   */\n  Vivus.prototype.play = function (speed, callback) {\n    this.instanceCallback = null;\n    if (speed && typeof speed === 'function') {\n      this.instanceCallback = speed; // first parameter is actually the callback function\n      speed = null;\n    } else if (speed && typeof speed !== 'number') {\n      throw new Error('Vivus [play]: invalid speed');\n    }\n    // if the first parameter wasn't the callback, check if the seconds was\n    if (callback && typeof callback === 'function' && !this.instanceCallback) {\n      this.instanceCallback = callback;\n    }\n    this.speed = speed || 1;\n    if (!this.handle) {\n      this.draw();\n    }\n    return this;\n  };\n\n  /**\n   * Stop the current animation, if on progress.\n   * Should not trigger any error.\n   *\n   */\n  Vivus.prototype.stop = function () {\n    if (this.handle) {\n      cancelAnimFrame(this.handle);\n      this.handle = null;\n    }\n    return this;\n  };\n\n  /**\n   * Destroy the instance.\n   * Remove all bad styling attributes on all\n   * path tags\n   *\n   */\n  Vivus.prototype.destroy = function () {\n    this.stop();\n    var i, path;\n    for (i = 0; i < this.map.length; i++) {\n      path = this.map[i];\n      path.el.style.strokeDashoffset = null;\n      path.el.style.strokeDasharray = null;\n      this.renderPath(i);\n    }\n  };\n\n  /**\n   * Utils methods\n   * include methods from Codrops\n   **************************************\n   */\n\n  /**\n   * Method to best guess if a path should added into\n   * the animation or not.\n   *\n   * 1. Use the `data-vivus-ignore` attribute if set\n   * 2. Check if the instance must ignore invisible paths\n   * 3. Check if the path is visible\n   *\n   * For now the visibility checking is unstable.\n   * It will be used for a beta phase.\n   *\n   * Other improvments are planned. Like detecting\n   * is the path got a stroke or a valid opacity.\n   */\n  Vivus.prototype.isInvisible = function (el) {\n    var rect,\n      ignoreAttr = el.getAttribute('data-ignore');\n    if (ignoreAttr !== null) {\n      return ignoreAttr !== 'false';\n    }\n    if (this.ignoreInvisible) {\n      rect = el.getBoundingClientRect();\n      return !rect.width && !rect.height;\n    } else {\n      return false;\n    }\n  };\n\n  /**\n   * Parse attributes of a DOM element to\n   * get an object of {attributeName => attributeValue}\n   *\n   * @param  {object} element DOM element to parse\n   * @return {object}         Object of attributes\n   */\n  Vivus.prototype.parseAttr = function (element) {\n    var attr,\n      output = {};\n    if (element && element.attributes) {\n      for (var i = 0; i < element.attributes.length; i++) {\n        attr = element.attributes[i];\n        output[attr.name] = attr.value;\n      }\n    }\n    return output;\n  };\n\n  /**\n   * Reply if an element is in the page viewport\n   *\n   * @param  {object} el Element to observe\n   * @param  {number} h  Percentage of height\n   * @return {boolean}\n   */\n  Vivus.prototype.isInViewport = function (el, h) {\n    var scrolled = this.scrollY(),\n      viewed = scrolled + this.getViewportH(),\n      elBCR = el.getBoundingClientRect(),\n      elHeight = elBCR.height,\n      elTop = scrolled + elBCR.top,\n      elBottom = elTop + elHeight;\n\n    // if 0, the element is considered in the viewport as soon as it enters.\n    // if 1, the element is considered in the viewport only when it's fully inside\n    // value in percentage (1 >= h >= 0)\n    h = h || 0;\n    return elTop + elHeight * h <= viewed && elBottom >= scrolled;\n  };\n\n  /**\n   * Get the viewport height in pixels\n   *\n   * @return {integer} Viewport height\n   */\n  Vivus.prototype.getViewportH = function () {\n    var client = this.docElem.clientHeight,\n      inner = window.innerHeight;\n    if (client < inner) {\n      return inner;\n    } else {\n      return client;\n    }\n  };\n\n  /**\n   * Get the page Y offset\n   *\n   * @return {integer} Page Y offset\n   */\n  Vivus.prototype.scrollY = function () {\n    return window.pageYOffset || this.docElem.scrollTop;\n  };\n  setupEnv = function () {\n    if (Vivus.prototype.docElem) {\n      return;\n    }\n\n    /**\n     * Alias for document element\n     *\n     * @type {DOMelement}\n     */\n    Vivus.prototype.docElem = window.document.documentElement;\n\n    /**\n     * Alias for `requestAnimationFrame` or\n     * `setTimeout` function for deprecated browsers.\n     *\n     */\n    requestAnimFrame = function () {\n      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( /* function */callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      };\n    }();\n\n    /**\n     * Alias for `cancelAnimationFrame` or\n     * `cancelTimeout` function for deprecated browsers.\n     *\n     */\n    cancelAnimFrame = function () {\n      return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {\n        return window.clearTimeout(id);\n      };\n    }();\n  };\n\n  /**\n   * Parse string to integer.\n   * If the number is not positive or null\n   * the method will return the default value\n   * or 0 if undefined\n   *\n   * @param {string} value String to parse\n   * @param {*} defaultValue Value to return if the result parsed is invalid\n   * @return {number}\n   *\n   */\n  parsePositiveInt = function (value, defaultValue) {\n    var output = parseInt(value, 10);\n    return output >= 0 ? output : defaultValue;\n  };\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function () {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n})();","map":{"version":3,"names":["Pathformer","element","Error","constructor","String","document","getElementById","window","SVGElement","SVGGElement","test","nodeName","el","scan","prototype","TYPES","ATTR_WATCH","svg","fn","pathData","pathDom","elements","querySelectorAll","join","i","length","tagName","toLowerCase","parseAttr","attributes","pathMaker","parentNode","replaceChild","lineToPath","newElement","x1","y1","x2","y2","d","rectToPath","x","parseFloat","y","width","height","rx","ry","parseInt","Math","min","max","polylineToPath","points","trim","split","path","indexOf","formattedPoints","push","polygonToPath","ellipseToPath","cx","cy","startX","startY","endX","endY","circleToPath","r","attr","pathTag","createElementNS","name","setAttribute","value","output","setupEnv","requestAnimFrame","cancelAnimFrame","parsePositiveInt","Vivus","options","callback","isReady","setElement","setOptions","setCallback","init","LINEAR","EASE","cos","PI","EASE_OUT","pow","EASE_IN","EASE_OUT_BOUNCE","base","rate","rateR","progress","abs","onLoad","self","parentEl","file","domSandbox","createElement","innerHTML","responseText","svgTag","querySelector","appendChild","oReq","XMLHttpRequest","addEventListener","open","send","SVGSVGElement","HTMLObjectElement","e","contentDocument","getAttribute","insertBefore","removeChild","allowedTypes","allowedStarts","undefined","Object","type","start","isIE","navigator","userAgent","duration","delay","dashGap","forceRender","hasOwnProperty","reverseStack","selfDestroy","onReady","map","frameLength","currentFrame","delayUnit","speed","handle","ignoreInvisible","animTimingFunction","pathTimingFunction","Function","mapping","paths","pAttrs","pathObj","totalLength","lengthMeter","timePoint","scale","hasNonScale","isInvisible","startAt","isResizeSensitive","rect","getBoundingClientRect","box","getBBox","ceil","getTotalLength","isNaN","console","warn","style","strokeDasharray","strokeDashoffset","renderPath","reverse","recalc","mustRecalcScale","performLineRecalc","bind","trace","draw","stop","reset","destroy","instanceCallback","floor","index","newPath","cloneNode","starter","play","listener","isInViewport","removeEventListener","getStatus","setFrameProgress","finish","round","ignoreAttr","h","scrolled","scrollY","viewed","getViewportH","elBCR","elHeight","elTop","top","elBottom","client","docElem","clientHeight","inner","innerHeight","pageYOffset","scrollTop","documentElement","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","setTimeout","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","id","clearTimeout","defaultValue","define","amd","exports","module"],"sources":["C:/workSpace/react/stSociety/oitaConferenceWork/develop/node_modules/vivus/dist/vivus.js"],"sourcesContent":["/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.4.6\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n(function () {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element instanceof window.SVGElement || \n      element instanceof window.SVGGElement ||\n      /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage.\n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n      elements = svg.querySelectorAll(this.TYPES.join(','));\n\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {},\n      x1 = element.x1 || 0,\n      y1 = element.y1 || 0,\n      x2 = element.x2 || 0,\n      y2 = element.y2 || 0;\n\n  newElement.d = 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n      x      = parseFloat(element.x)      || 0,\n      y      = parseFloat(element.y)      || 0,\n      width  = parseFloat(element.width)  || 0,\n      height = parseFloat(element.height) || 0;\n\n  if (element.rx || element.ry) {\n    var rx = parseInt(element.rx, 10) || -1,\n        ry = parseInt(element.ry, 10) || -1;\n    rx = Math.min(Math.max(rx < 0 ? ry : rx, 0), width/2);\n    ry = Math.min(Math.max(ry < 0 ? rx : ry, 0), height/2);\n\n    newElement.d = 'M ' + (x + rx) + ',' + y + ' ' +\n                   'L ' + (x + width - rx) + ',' + y + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width) + ',' + (y + ry) + ' ' +\n                   'L ' + (x + width) + ',' + (y + height - ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width - rx) + ',' + (y + height) + ' ' +\n                   'L ' + (x + rx) + ',' + (y + height) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + x + ',' + (y + height - ry) + ' ' +\n                   'L ' + x + ',' + (y + ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + rx) + ',' + y;\n  }\n  else {\n    newElement.d = 'M' + x + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + (y + height) + ' ' +\n                   'L' + x + ' ' + (y + height) + ' Z';\n  }\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var newElement = {},\n      points = element.points.trim().split(' '),\n      i, path;\n\n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var newElement = {},\n      rx = parseFloat(element.rx) || 0,\n      ry = parseFloat(element.ry) || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - rx,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(rx),\n      endY = cy;\n\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {},\n      r  = parseFloat(element.r)  || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - r,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(r),\n      endY = cy;\n      \n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar setupEnv, requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'sync'|'oneByOne'|'script' (to know if the items must be drawn synchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'sync'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus(element, options, callback) {\n  setupEnv();\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n **************************************\n *\n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR = function(x) {\n  return x;\n};\nVivus.EASE = function(x) {\n  return -Math.cos(x * Math.PI) / 2 + 0.5;\n};\nVivus.EASE_OUT = function(x) {\n  return 1 - Math.pow(1 - x, 3);\n};\nVivus.EASE_IN = function(x) {\n  return Math.pow(x, 3);\n};\nVivus.EASE_OUT_BOUNCE = function(x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base, 1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI))) + 1;\n  return 1 - rateR + progress * rateR;\n};\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function(element, options) {\n  var onLoad, self;\n\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not related to an existing ID'\n      );\n    }\n  }\n  this.parentEl = element;\n\n  // Load the SVG with XMLHttpRequest and extract the SVG\n  if (options && options.file) {\n    self = this;\n    onLoad = function() {\n      var domSandbox = document.createElement('div');\n      domSandbox.innerHTML = this.responseText;\n\n      var svgTag = domSandbox.querySelector('svg');\n      if (!svgTag) {\n        throw new Error(\n          'Vivus [load]: Cannot find the SVG in the loaded file : ' +\n            options.file\n        );\n      }\n\n      self.el = svgTag;\n      self.el.setAttribute('width', '100%');\n      self.el.setAttribute('height', '100%');\n      self.parentEl.appendChild(self.el);\n      self.isReady = true;\n      self.init();\n      self = null;\n    };\n\n    var oReq = new window.XMLHttpRequest();\n    oReq.addEventListener('load', onLoad);\n    oReq.open('GET', options.file);\n    oReq.send();\n    return;\n  }\n\n  switch (element.constructor) {\n    case window.SVGSVGElement:\n    case window.SVGElement:\n    case window.SVGGElement:\n      this.el = element;\n      this.isReady = true;\n      break;\n\n    case window.HTMLObjectElement:\n      self = this;\n      onLoad = function(e) {\n        if (self.isReady) {\n          return;\n        }\n        self.el =\n          element.contentDocument &&\n          element.contentDocument.querySelector('svg');\n        if (!self.el && e) {\n          throw new Error(\n            'Vivus [constructor]: object loaded does not contain any SVG'\n          );\n        } else if (self.el) {\n          if (element.getAttribute('built-by-vivus')) {\n            self.parentEl.insertBefore(self.el, element);\n            self.parentEl.removeChild(element);\n            self.el.setAttribute('width', '100%');\n            self.el.setAttribute('height', '100%');\n          }\n          self.isReady = true;\n          self.init();\n          self = null;\n        }\n      };\n\n      if (!onLoad()) {\n        element.addEventListener('load', onLoad);\n      }\n      break;\n\n    default:\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)'\n      );\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function(options) {\n  var allowedTypes = [\n    'delayed',\n    'sync',\n    'async',\n    'nsync',\n    'oneByOne',\n    'scenario',\n    'scenario-sync'\n  ];\n  var allowedStarts = ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error(\n      'Vivus [constructor]: \"options\" parameter must be an object'\n    );\n  } else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.type +\n        ' is not an existing animation `type`'\n    );\n  } else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.start +\n        ' is not an existing `start` option'\n    );\n  } else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE =\n    window.navigator.userAgent.indexOf('MSIE') !== -1 ||\n    window.navigator.userAgent.indexOf('Trident/') !== -1 ||\n    window.navigator.userAgent.indexOf('Edge/') !== -1;\n  this.duration = parsePositiveInt(options.duration, 120);\n  this.delay = parsePositiveInt(options.delay, null);\n  this.dashGap = parsePositiveInt(options.dashGap, 1);\n  this.forceRender = options.hasOwnProperty('forceRender')\n    ? !!options.forceRender\n    : this.isIE;\n  this.reverseStack = !!options.reverseStack;\n  this.selfDestroy = !!options.selfDestroy;\n  this.onReady = options.onReady;\n  this.map = [];\n  this.frameLength = this.currentFrame = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible')\n    ? !!options.ignoreInvisible\n    : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function(callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error(\n      'Vivus [constructor]: \"callback\" parameter must be a function'\n    );\n  }\n  this.callback = callback || function() {};\n};\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function() {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint, scale, hasNonScale;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n  hasNonScale = false;\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n\n    pathObj = {\n      el: path,\n      length: 0,\n      startAt: 0,\n      duration: 0,\n      isResizeSensitive: false\n    };\n\n    // If vector effect is non-scaling-stroke, the total length won't match the rendered length\n    // so we need to calculate the scale and apply it\n    if (path.getAttribute('vector-effect') === 'non-scaling-stroke') {\n      var rect = path.getBoundingClientRect();\n      var box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.isResizeSensitive = true;\n      hasNonScale = true;\n    } else {\n      scale = 1;\n    }\n    pathObj.length = Math.ceil(path.getTotalLength() * scale);\n\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn(\n          'Vivus [mapping]: cannot retrieve a path element length',\n          path\n        );\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray =\n      pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  // Show a warning for non-scaling elements\n  if (hasNonScale) {\n    console.warn('Vivus: this SVG contains non-scaling-strokes. You should call instance.recalc() when the SVG is resized or you will encounter unwanted behaviour. See https://github.com/maxwellito/vivus#non-scaling for more info.');\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  // Reverse stack if asked\n  if (this.reverseStack) {\n    this.map.reverse();\n  }\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n      case 'delayed':\n        pathObj.startAt = this.delayUnit * i;\n        pathObj.duration = this.duration - this.delay;\n        break;\n\n      case 'oneByOne':\n        pathObj.startAt = (lengthMeter / totalLength) * this.duration;\n        pathObj.duration = (pathObj.length / totalLength) * this.duration;\n        break;\n\n      case 'sync':\n      case 'async':\n      case 'nsync':\n        pathObj.startAt = 0;\n        pathObj.duration = this.duration;\n        break;\n\n      case 'scenario-sync':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          timePoint +\n          (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        timePoint =\n          pAttrs['data-async'] !== undefined\n            ? pathObj.startAt\n            : pathObj.startAt + pathObj.duration;\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n\n      case 'scenario':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Public method to re-evaluate line length for non-scaling lines\n * path elements.\n */\nVivus.prototype.recalc = function () {\n  if (this.mustRecalcScale) {\n    return;\n  }\n  this.mustRecalcScale = requestAnimFrame(function () {\n    this.performLineRecalc();\n  }.bind(this));\n}\n\n/**\n * Private method to re-evaluate line length on non-scaling\n * path elements. Then call for a trace to update the SVG. \n */\nVivus.prototype.performLineRecalc = function () {\n  var pathObj, path, rect, box, scale;\n  for (var i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n    if (pathObj.isResizeSensitive) {\n      path = pathObj.el;\n      rect = path.getBoundingClientRect();\n      box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.length = Math.ceil(path.getTotalLength() * scale);\n      path.style.strokeDasharray = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    }\n  }\n  this.trace();\n  this.mustRecalcScale = null;\n}\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.draw = function() {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function() {\n      self.draw();\n    });\n    return;\n  }\n\n  this.callback(this);\n  if (this.instanceCallback) {\n    this.instanceCallback(this);\n    this.instanceCallback = null;\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function() {\n  var i, progress, path, currentFrame;\n  currentFrame =\n    this.animTimingFunction(this.currentFrame / this.frameLength) *\n    this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n *\n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function(index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n      newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n *\n */\nVivus.prototype.init = function() {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function() {\n  switch (this.start) {\n    case 'manual':\n      return;\n\n    case 'autostart':\n      this.play();\n      break;\n\n    case 'inViewport':\n      var self = this,\n        listener = function() {\n          if (self.isInViewport(self.parentEl, 1)) {\n            self.play();\n            window.removeEventListener('scroll', listener);\n          }\n        };\n      window.addEventListener('scroll', listener);\n      listener();\n      break;\n  }\n};\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function() {\n  return this.currentFrame === 0\n    ? 'start'\n    : this.currentFrame === this.frameLength\n    ? 'end'\n    : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function() {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function() {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n *\n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function(progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function(speed, callback) {\n  this.instanceCallback = null;\n\n  if (speed && typeof speed === 'function') {\n    this.instanceCallback = speed; // first parameter is actually the callback function\n    speed = null;\n  } else if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  // if the first parameter wasn't the callback, check if the seconds was\n  if (callback && typeof callback === 'function' && !this.instanceCallback) {\n    this.instanceCallback = callback;\n  }\n\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.draw();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function() {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function() {\n  this.stop();\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function(el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function(element) {\n  var attr,\n    output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function(el, h) {\n  var scrolled = this.scrollY(),\n    viewed = scrolled + this.getViewportH(),\n    elBCR = el.getBoundingClientRect(),\n    elHeight = elBCR.height,\n    elTop = scrolled + elBCR.top,\n    elBottom = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return elTop + elHeight * h <= viewed && elBottom >= scrolled;\n};\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function() {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  } else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function() {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\nsetupEnv = function() {\n  if (Vivus.prototype.docElem) {\n    return;\n  }\n\n  /**\n   * Alias for document element\n   *\n   * @type {DOMelement}\n   */\n  Vivus.prototype.docElem = window.document.documentElement;\n\n  /**\n   * Alias for `requestAnimationFrame` or\n   * `setTimeout` function for deprecated browsers.\n   *\n   */\n  requestAnimFrame = (function() {\n    return (\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(/* function */ callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      }\n    );\n  })();\n\n  /**\n   * Alias for `cancelAnimationFrame` or\n   * `cancelTimeout` function for deprecated browsers.\n   *\n   */\n  cancelAnimFrame = (function() {\n    return (\n      window.cancelAnimationFrame ||\n      window.webkitCancelAnimationFrame ||\n      window.mozCancelAnimationFrame ||\n      window.oCancelAnimationFrame ||\n      window.msCancelAnimationFrame ||\n      function(id) {\n        return window.clearTimeout(id);\n      }\n    );\n  })();\n};\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function(value, defaultValue) {\n  var output = parseInt(value, 10);\n  return output >= 0 ? output : defaultValue;\n};\n\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n\n}());\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}